# -*- coding: utf-8 -*-
"""binary-tree-and-shortest-transformation-sequence.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZlNS76qG2FLjyX3aPLkmZ6QjXfi5DXSh
"""

from collections import deque

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

#Function to return the maximum width of the given tree, which is the maximum width among all levels, given the root of a binary tree.
def widthOfBinaryTree(root: TreeNode) -> int:
    if not root:
        return 0

    # Queue will store tuples of node and its index at the current level
    queue = deque([(root, 0)])
    max_width = 0

    while queue:
        level_length = len(queue)
        _, first_index = queue[0]  # Index of the first node at the current level
        for _ in range(level_length):
            node, index = queue.popleft()
            if node.left:
                queue.append((node.left, 2 * index))
            if node.right:
                queue.append((node.right, 2 * index + 1))

        # Calculate width of the current level
        current_width = index - first_index + 1
        if current_width > max_width:
            max_width = current_width

    return max_width

# Function to build the tree from the list representation
def build_tree(values):
    # Constraint 1: The number of nodes in the tree should be between 1 and 3000
    if not (1 <= len(values) <= 3000):
        raise ValueError("Number of nodes should be between 1 and 3000.")

    # Constraint 2: Node values should be between -100 and 100
    if not all((val is None or -100 <= val <= 100) for val in values):
        raise ValueError("Node values must be between -100 and 100.")


    if not values:
        return None
    root = TreeNode(values[0])
    queue = deque([root])
    index = 1
    while index < len(values):
        node = queue.popleft()
        if values[index] is not None:
            node.left = TreeNode(values[index])
            queue.append(node.left)
        index += 1
        if index < len(values) and values[index] is not None:
            node.right = TreeNode(values[index])
            queue.append(node.right)
        index += 1
    return root

root_values = [1, 3, 2, 5, None, None, 9, 6, None, 7]

# Calling the functions
root = build_tree(root_values)
max_width = widthOfBinaryTree(root)
print(f"Output: {max_width}")

#Function to return the maximum path sum of any non-empty path, given the root of a binary tree.
def maxPathSum(root):
    def helper(node):
        nonlocal max_sum
        if not node:
            return 0

        # Compute maximum path sum including left and right children
        left_sum = helper(node.left)
        right_sum = helper(node.right)

        # Current path sum including this node
        current_sum = node.val + left_sum + right_sum

        # Update global maximum
        max_sum = max(max_sum, current_sum)

        # Return maximum gain if continuing the path through this node
        return node.val

    max_sum = float('-inf')
    helper(root)
    return max_sum

# function to validate tree input constraints
def validate_tree_input(root):
    def count_nodes(node):
        if not node:
            return 0
        return 1 + count_nodes(node.left) + count_nodes(node.right)

    def validate_node_values(node):
        if not node:
            return True
        if not (-1000 <= node.val <= 1000):
            return False
        return validate_node_values(node.left) and validate_node_values(node.right)

    # Constraint 1: Number of nodes in the range [1, 3 * 10^4]
    total_nodes = count_nodes(root)
    if total_nodes < 1 or total_nodes > 30000:
        raise ValueError("The number of nodes must be in the range [1, 30000].")

    # Constraint 2: Node values in the range [-1000, 1000]
    if not validate_node_values(root):
        raise ValueError("Node values must be in the range [-1000, 1000].")

# Example
root = TreeNode(-10)
root.left = TreeNode(9)
root.right = TreeNode(20)
root.left.left = None
root.left.right = None
root.right.left = TreeNode(15)
root.right.right = TreeNode(7)

# Validate the input tree based on the given constraints
validate_tree_input(root)

# Calling the function
print(f"Output: {maxPathSum(root)}")

#Function to return the number of words in the shortest transformation sequence from beginWord to endWord,
# given two words, beginWord and endWord, and a dictionary wordList.
def ladderLength(beginWord, endWord, wordList):
    # If the endWord is not in the wordList, return 0
    if (endWord not in wordList or beginWord in wordList):
        return 0

    # Initialize BFS
    queue = deque([(beginWord, 1)])  # (word, distance)
    visited = set()
    visited.add(beginWord)

    # Process the queue
    while queue:
        current_word, length = queue.popleft()

        # Try all possible single letter transformations
        for i in range(len(current_word)):
            for char in 'abcdefghijklmnopqrstuvwxyz':
                transformed_word = current_word[:i] + char + current_word[i+1:]

                # If we find the endWord, return the length
                if transformed_word == endWord:
                    return length + 1

                # If transformed_word is valid and not visited, add it to the queue
                if transformed_word in wordList and transformed_word not in visited:
                    visited.add(transformed_word)
                    queue.append((transformed_word, length + 1))

    return 0  # If no transformation sequence exists

# Example

beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log","cog"]
print(ladderLength(beginWord, endWord, wordList))

beginWord = "hit"
endWord = "mol"
wordList = ["lit", "lot", "set", "sot", "rot", "rol", "mol"]
print(ladderLength(beginWord, endWord, wordList))